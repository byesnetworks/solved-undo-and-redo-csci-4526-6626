Download Link: https://assignmentchef.com/product/solved-undo-and-redo-csci-4526-6626
<br>
5/5 - (1 vote)

1 Goals&#xf; To build a Stack class by using an stl template.&#xf; To be able to undo and redo moves.2 Changes to Other ClassesChanges to the Game class. The Game::run() function displays a menu and accepts selections, which are processed by a switch. The switch should call action functions to carry out most of the user’s choices. Try to limit the code that is actually inside teach case to three lines. If you have not already done so, move longer blocks of code out of the switch into separate functions.Activate menu options undo and redo. Also instantiate two stacks of BoardState*s: the undo stack and the redo stack. Use the Stack class de ned below, which is adapted from the stl Stack template. The undo stack always holds a copy of the current state of the game. The redo stack holds states that have been undone, until they are ready to be redone. The Game class has custodyof these dynamically allocated objects and is responsible for deallocating them whenever one is discarded.Every time you make a move or turn oa possibility, another BoardState&#x3; will be pushed onto the undo stack. When you ask to undo or redo an action, a BoardState&#x3; will be popped from oneof the stacks and used to update the state of the Board. When you stop doing undos and redosand again call move or turn, the redo history becomes invalid. Thus, any call to move or turnomust zap (empty) the redo stack. At the end of a game, the undo stack contains a complete historyof your successful moves. (This history could be written to a le if anyone was interested in it.)Add to the actions for the Move menu item. Immediately after the user makes a move, do thefollowing:&#xf; Create a new BoardState object, initialized to the state after the move.&#xf; Push the pointer onto the undo stack.&#xf; Clear the redo stack.Implement the undo menu item, keeping in mind that you can’t undo unless the stack has 2 ormore BoardStates.&#xf; Pop one BoardState* o&#xb; the undo stack, then&#xf; Push the pointer onto the redo stack.&#xf; Then restore the Board state to the state on top of the undo stack, as de ned below.Implement the redo menu item:&#xf; Return without doing anything if the redo stack is empty.&#xf; Pop one BoardState* o&#xb; the redo stack, then&#xf; Push the pointer onto the undo stack.&#xf; Then restore the Board state to the state on top of the undo stack, as de ned below.9: undo and redo CSCI 4526 / 6626 Fall 2016 2Changes to the Board class. Add a function restoreState( BoardState* ). This will loop through the 81 squares in the parameter BoardState and copy the information into the State portion of each Square. Call this from the Game class after either an undo or a redo.3 The Stack ClassImplementing a Stack. The standard template library has a template named stack&lt;T that does approximately (but not exactly) what we want in this application. However, it is very easy to adapt the vector&lt;T template and create a stack with the right functionality. Our strategy will be to instantiate the stl template as vector&lt;BoardState* and at the same time, on the same line, derive the class Stack from it. Private derivation is needed to close o&#xb; access to many unwantedvector&lt;T functions. However, private derivation forces us to de ne, in Stack, all of the functions we want to keep. In the derived class, you will need these functions; de ne them all as inline functions:&#xf; Constructor and destructor.&#xf; void pop(); Delegate to vector::pop_back()&#xf; BoardState* top(); Delegate to vector::top()&#xf; void push( BoardState* ); Delegate to vector::push_back( BoardState* )&#xf; int size(); Return the number of BoardStates on the stack (in the vector).&#xf; void zap(); Empty the entire stack by popping everything o&#xb; it. Remember that this involves freeing dynamic memory.This Stack class is an adapter class: it adapts vector to our needs by adding, removing, and renaming functions. The rst three functions, above, rename the functions inherited from vector.To implement them, simply call the appropriate function from the vector class. One function, size(), has the same name as the underlying function in vector. For that one function, you must use the :: operator to call the size() function from the base class. (Otherwise, an attempt to delegate becomes an in nite recursion and your program will end with a segmentation error. I unthinkingly tried it. Bad news!)